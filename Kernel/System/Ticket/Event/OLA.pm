# --
# Kernel/System/Ticket/Event/OLA.pm - a event module for OLA accounting
# Copyright (C) 2001-2016 Complemento - Liberdade e Tecnologia http://www.complemento.net.br
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Ticket::Event::OLA;

use strict;
use warnings;

use Data::Dumper;

use Kernel::System::VariableCheck qw(:all);

our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::DynamicField',
    'Kernel::System::DynamicField::Backend',
    'Kernel::System::Log',
    'Kernel::System::Ticket',
);

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    return $Self;
}

sub Run {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(Data Event Config UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }
    for (qw(TicketID)) {
        if ( !$Param{Data}->{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_ in Data!"
            );
            return;
        }
    }

    # Instance OLA Object
    my $OLAObject = $Kernel::OM->Get('Kernel::System::OLA');
    
    my %Ticket = $Kernel::OM->Get('Kernel::System::Ticket')->TicketGet(
        TicketID      => $Param{Data}->{TicketID},
        DynamicFields => 1,
    );


    # IF TICKET DOES NOT HAVE SLA, Clean OLA information from previous possible SLA and return
    if (!$Ticket{SLAID}){
        $OLAObject->CleanQueueOlaInformation( Ticket => \%Ticket );
        return 1;
    }

    # Get OLA Sla Preference
    my $SLAObject = $Kernel::OM->Get('Kernel::System::SLA');
    my %Preferences = $SLAObject->SLAPreferencesGet(
       SLAID  => $Ticket{SLAID},
       UserID => 1,
    );
    # IF there is no information about OLA in this new SLA, clean OLA information from previous possible SLA and return
    if (! defined $Preferences{'OLA_Queues'} || $Preferences{'OLA_Queues'} eq '')
    {
        $OLAObject->CleanQueueOlaInformation( Ticket => \%Ticket );
        return 1
    }

    my $DynamicFieldObject = $Kernel::OM->Get('Kernel::System::DynamicField');
    my $BackendObject = $Kernel::OM->Get('Kernel::System::DynamicField::Backend');
    
    # PARSE OLA Queue from this SLA
    my $JSONObject = $Kernel::OM->Get('Kernel::System::JSON');
    my %OlaQueues = %{$JSONObject->Decode(
                        Data => $Preferences{'OLA_Queues'},
                    )};
    my %SLAData = $SLAObject->SLAGet(
        SLAID  => $Ticket{SLAID},
        UserID => 1,
    );
    my %Queue    = $Kernel::OM->Get('Kernel::System::Queue')->QueueGet(ID => $Ticket{QueueID});
    my @Queues = keys %OlaQueues;

    #### Rebuilding OLA Escalation Event (generated by cron task / Daemon)
    if ($Param{Event} eq 'RebuildIndex'){
        my @RunningStates = ("In Progress","In Progress - Alert","In Progress - Expired");
        
        if (scalar grep $_ eq $Ticket{"DynamicField_OlaQueue".$Ticket{QueueID}."State"},@RunningStates)
        {
            my $OlaStateField = $DynamicFieldObject->DynamicFieldGet(
               Name => "OlaQueue".$Ticket{QueueID}."State",
            );

            my $OlaDiffField = $DynamicFieldObject->DynamicFieldGet(
               Name => "OlaQueue".$Ticket{QueueID}."Diff",
            );

            my $NewDiff = $OLAObject->FastDiffAndState(
                TicketID        => $Param{Data}->{TicketID},
                Destination     => $Ticket{"DynamicField_OlaQueue".$Ticket{QueueID}."Destination"},
                CurrentOlaState => $Ticket{"DynamicField_OlaQueue".$Ticket{QueueID}."State"},
                # PreviousOlaDiff => $Ticket{"DynamicField_OlaQueue".$Ticket{QueueID}."Diff"},
                OlaStateFieldId => $OlaStateField->{ID},
                OlaDiffFieldId  => $OlaDiffField->{ID},
            );
            
        }
        
        return 1;
    }    
    
    #### Other Ticket events (TicketCreate, SLAUpdate, QueueUpdate and StateUpdate)
    my @NotAccountedTicketStates = $OLAObject->GetNotAccountedTicketStates();

    my $CalendarUse = $SLAData{Calendar} || '';
    if($OlaQueues{$Ticket{QueueID}} && $OlaQueues{$Ticket{QueueID}}->{Calendar}){
      $CalendarUse = $OlaQueues{$Ticket{QueueID}}->{Calendar};
    }


    my %QueueAccountedTime = %{ $OLAObject->GetQueuesAccountedTime( 
                                    TicketID  => $Param{Data}->{TicketID}, 
                                    OlaQueues => \%OlaQueues,
                                    Calendar  => $CalendarUse),
                              };

    my @TicketUsedQueues = $OLAObject->GetTicketUsedQueues(TicketID=>$Param{Data}->{TicketID});

    # Para Cada fila onde o chamado passou
    for my $QueueID (@TicketUsedQueues){
        # Se a fila não está na lista de filas deste OLA (@Queues), limpa a informação de OLA
        if (! defined $QueueAccountedTime{$QueueID}){
            $OLAObject->CleanQueueOlaInformation( Ticket => \%Ticket, QueueID => $QueueID );
        } else {
            # Se estiver na lista @Queues
            # Verifica se campos existem e os cria se necessário:
            $OLAObject->CheckAndCreateQueueOlaDynamicFields(
                QueueID => $QueueID
            );
            
            # Configura Diff e Destination
            my $DiffDF = $DynamicFieldObject->DynamicFieldGet(
                Name => "OlaQueue".$QueueID."Diff",
            );
            my $DestDF = $DynamicFieldObject->DynamicFieldGet(
                Name => "OlaQueue".$QueueID."Destination",
            );
            my $StateDF = $DynamicFieldObject->DynamicFieldGet(
                Name => "OlaQueue".$QueueID."State",
            );
            
            my $State;

            $Kernel::OM->Get('Kernel::System::DynamicFieldValue')->ValueSet(
                    FieldID  => $DiffDF->{ID},
                    ObjectID => $Param{Data}->{TicketID},
                    Value    => [
                        {
                            ValueText => $QueueAccountedTime{$QueueID}->{"Diff"},
                        },
                    ],
                    UserID => 1,
            );
            
            $Kernel::OM->Get('Kernel::System::DynamicFieldValue')->ValueSet(
                    FieldID  => $DestDF->{ID},
                    ObjectID => $Param{Data}->{TicketID},
                    Value    => [
                        {
                            ValueDateTime => $QueueAccountedTime{$QueueID}->{"DestinationTime"},
                        },
                    ],
                    UserID => 1,
            );
                        
            # Se (não for a fila atual) ou (Se for fila atual mas estado do chamado é de pausa (fechado, aguardo cliente etc)):
            if ( ($QueueID ne $Ticket{QueueID}) || 
                 (($QueueID eq $Ticket{QueueID}) && (scalar grep $_ eq $Ticket{StateID}, @NotAccountedTicketStates)) ){
                    # Se o tempo gasto for maior que o OLA da fila, ou seja Diff Negativo
                    if ($QueueAccountedTime{$QueueID}->{"Diff"} < 0)
                    {
                        $State = 'Stopped - Expired';
                    } else {
                        # Se for positivo
                        $State = 'Stopped';
                    }

            } elsif ($QueueID eq $Ticket{QueueID}) {
            # Se a fila que esta sendo calculada é a atual e estado do chamado conta OLA:
                    if ($QueueAccountedTime{$QueueID}->{"Diff"} < 0)
                    {
                        $State = 'In Progress - Expired';
                    } elsif (defined $OlaQueues{$QueueID}->{"Notify"} &&
                        $OlaQueues{$QueueID}->{"Notify"} ne '' &&
                        $OlaQueues{$QueueID}->{"Notify"} > 0 &&
                        ( $QueueAccountedTime{$QueueID}->{"Diff"} < ( $OlaQueues{$QueueID}->{"Time"} * (1-($OlaQueues{$QueueID}->{"Notify"}/100))) ) )
                         {
                        # Se for positivo
                        $State = 'In Progress - Alert';
                    } else {
                        $State = 'In Progress';
                    }
            }
            # Armazena o valor do State
            $BackendObject->ValueSet(
                DynamicFieldConfig => $StateDF,
                ObjectID           => $Param{Data}->{TicketID},
                Value              => $State,
                UserID             => 1,
            );

        }
    }

    return 1;
}

1;
